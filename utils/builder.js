import { OUTPUT_DIR } from "./constants.js"
import { join, dirname, relative } from "path"
import {
  writeFileSync,
  rmSync,
  mkdirSync,
  cpSync,
  existsSync,
  readFileSync,
} from "fs"
import { states } from "./out.js"
import zipper from "zip-local"
import glob from "glob"

export default function builder(icmod, mode) {
  let dist_dir = join(icmod.root, OUTPUT_DIR, mode)
  let output_dir = join(dist_dir, icmod.config.package.name)

  function createModInfo() {
    if (mode == "release") {
      if (!icmod.config.package.author) {
        throw error(
          "Config Error",
          "`author` must me provided in `icmod.toml` in release mode",
        )
      }

      if (!icmod.config.package.description) {
        throw error(
          "Config Error",
          "`description` must me provided in `icmod.toml` in release mode",
        )
      }
    }

    return {
      name: icmod.config.package.name,
      version: icmod.config.package.version,
      author: icmod.config.package.author,
      description: icmod.config.package.description,
    }
  }

  function createBuildConfig() {
    let build_config = {
      defaultConfig: {
        api: icmod.config.build.api,
        buildType: "develop",
        // TODO: move to constants
        libraryDir: "lib/",
        resourcePacksDir: "assets/resource_packs",
        behaviorPacksDir: "assets/behavior_packs",
      },
    }

    if (mode === "debug") {
      build_config.buildDirs = [
        {
          dir: "src/",
          targetSource: "main.js",
        },
      ]
      build_config.compile = [
        {
          path: "main.js",
          sourceType: "mod",
        },
        {
          path: "launcher.js",
          sourceType: "launcher",
        },
      ]
      // TODO: move to buildScripts state
      cpSync(join(icmod.root, "src"), join(output_dir, "src"), {
        recursive: true,
      })

      cpSync(
        join(icmod.root, icmod.config.build.launcher),
        join(output_dir, "launcher.js"),
      )

      let jsconfig_file = join(icmod.root, "jsconfig.json")
      let includes = new Set()
      const src_dir = join(icmod.root, "src")
      if (existsSync(jsconfig_file)) {
        let jsconfig = JSON.parse(readFileSync(jsconfig_file))

        // TODO: warn if jsconfig.include is empty

        jsconfig.include?.forEach(e => {
          if (glob.hasMagic(e)) {
            let files = glob.sync(e).map(e => relative(src_dir, e))
            files.forEach(e => includes.add(e))
          } else {
            let relpath = relative(src_dir, e)
            includes.delete(relpath)
            includes.add(relpath)
          }
        })
      } else {
        // TODO: implement tsconfig.json
        throw error(
          "Build Error",
          `\`jsconfig.json\` not found in \`${icmod.root}\``,
        )
      }

      const includes_file = join(output_dir, "src", ".includes")
      writeFileSync(
        includes_file,
        ["// this file is autogenerated", "", ...includes].join("\n"),
      )
    } else if (mode === "release") {
      // TODO: bundle javascript to one file
    }

    return build_config
  }

  return {
    get output() {
      return output_dir
    },
    *build() {
      yield states.compile(
        ms =>
          `${icmod.config.package.name} v${icmod.config.package.version} (${
            icmod.root
          }) in ${(ms / 1000).toFixed(2)}s`,
      )

      cleanDir(output_dir)

      // mod.info
      const mod_info = createModInfo()
      writeJsonFile(join(output_dir, "mod.info"), mod_info)

      // build.config
      const build_config = createBuildConfig()
      writeJsonFile(join(output_dir, "build.config"), build_config)

      // .includes
      // resources
      // native
      // java
      // typescript
    },
    *bundle() {
      const zip_file = join(dist_dir, `${icmod.config.package.name}.icmod`)
      yield states.bundle(
        ms =>
          `${mode} (${relative(icmod.root, zip_file)}) in ${(ms / 100).toFixed(
            2,
          )}s`,
      )
      rmSync(zip_file, { force: true })
      zipper.sync.zip(dirname(output_dir)).compress().save(zip_file)
    },
  }
}

function writeJsonFile(file, data) {
  writeFileSync(file, JSON.stringify(data, null, "  "))
}

function cleanDir(path) {
  rmSync(path, { recursive: true, force: true })
  mkdirSync(path, { recursive: true })
}
